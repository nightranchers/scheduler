import random

def buildSlotList(begin, end, slotSize):
        """
        take a beginning time and end time to create a dictionary with slots of size slotSize
        
        begin (int) is a 24hr 4 digit time e.g. 2359
        end (int) is also a 24hr 4 digit time
        slotSize (int) is the length in minutes you want each time slot to be
        """
        slot = begin
        #we also create a list of the slot times
        slotList = []
        while slot < end:
            #we're formatting for time here
            if slot % 100 < 60:
                slotList.append(slot)
            #if the minutes is more than 60, add 40 to bring it to the next hour
            else:
                slot += 40
                #if the hour adjustment brings us past the end point, exit the loop
                if slot >= end:
                    break
                slotList.append(slot)
            slot += slotSize
            return slotList
            
def buildSlots(slotList, contents):
    """
    take a slot list and return a dictionary of empty slot values ready for the user to fill
    
    slotList (list) is a list of slots previously created. we will iterate over this list to fill the slots
    contents (string) ("obj" or "list") is the type of content we intend to store in each slot
    """
    slots = {}
    for slot in slotList:
        #slots will be filled with a Position object, a list of Employee objects, or a single Employee object
        if contents == "obj":
            slots[slot] = None
        elif contents == "list":
            slots[slot] = []
        else:
            raise Exception(contents)
    return slots

#Implement Employee class
class Employee(object):
    def __init__(self, name, EOS):
        """
        initialize values for Employee
        
        name (str) is name of employee
        EOS (int) is employees End Of Shift time in 24hr local time (eg.2330)
        """
        self.name = name
        self.initials = name ##### WERE DOING THIS FOR SIMPLICITY's SAKE!!! CHANGE LATER!!! #####
        self.EOS = EOS
        #we'll keep track of the last position employee worked to try and keep variety
        self.lastPosition = None
        #TOP is Time On Position. Not to exceed user defined MaxTOP
        self.TOP = 0
        #TOB is Time On Break. Used to decide who gets called onto position
        self.TOB = 0

    def __str__(self):
        return self.name
        
    def getInitials(self):
        return self.initials
        
    def getEOS(self):
        return self.EOS
		
    def getLastPos(self):
        return self.lastPosition
        
    def setLastPos(self, lastPos):
        self.lastPosition = lastPos
        
    def increaseTOP(self, slots = 1):
        self.TOP += slots
        
    def resetTOP(self):
        self.TOP = 0
        
    def getTOP(self):
        return self.TOP
        
    def setTOBplus1(self):
        self.TOB += 1
        
    def resetTOB(self):
        self.TOB = 0
        
    def getTOB(self):
        return self.TOB       

#we can create an object class for each position so we can save its attributes
class Position(object):
    def __init__(self, posID, slotSize):
        """
        initialize Position object
        we can create one of these for each position we want to schedule
        
        posID (str) is the coded id of the position
        e.g. East = EST, Local Control = LC
        slotSize (int) is the length of slot size we desire for the position
        """
        self.posID = posID
        self.slotSize = slotSize
        self.slotList = buildSlotList(1800,2400, self.slotSize)
        self.slots = buildSlots(self.slotList, "obj")
        
    def __str__(self):
    	return self.posID
    	
    def getPosID(self):
        return self.posID
    	
    ##### WORK IN PROGRESS #####
    def assignWorker(self, slot, person, numSlots = 1):
    	"""
    	slot (int) is the slot you wish to insert worker
    	something (anything) is whatever you want to insert into the slot. typically an Employee object or list of Employees
    	numSlots (int) (default 1) is the amount of slots to fill beginning with slot
    	"""
    	if numSlots == 1:
            self.slots[slot] = person
            person.increaseTOP() #this adds to the person's time on position so we can see if he's been on too long
    	elif numSlots > 1:
            index = self.getSlotList().index(slot)
            slots = self.getSlotList()[index - numSlots + 1 : index + 1]
            for slot in slots:
                self.slots[slot] = person
                person.increaseTOP() #this adds to the person's time on position so we can see if he's been on too long
    	else:
           raise Exception("numSlots less than 1")    	
    	    	    	
    def checkSlot(self, slot, thing = Employee):
        if type(self.slots[slot]) == thing:
            return True
        else:
            return False
    	
    def getSlotList(self):
    	return self.slotList
    	
    def getSlotSize(self):
    	return self.slotSize
    	
    def getNumSlots(self):
        return len(self.slotList)
    	
    #this is redundant to "whoIsWorking"
    def getSlot(self, slot):
        return self.slots[slot]    	
    
    #this is redundant to "getSlot"		
    def whoIsWorking(self, slot):
        return self.getSlot(slot)
        

#implement Facility class
class Facility(object):
    def __init__(self, name, start=1800, end=2400, maxTOP = 105, slotSize = 15):
	"""
	initialize values for Facility object
	here we set the facility parameters that will be used when making the schedule

	name (str): name of facility
       
        optional parameters...
        start (int): this is the 24hr local time we want to begin creating the schedule
        end (int): this is the 24hr local time we want to stop creating the schedule
        maxTOP (int): we can set max time on position (maxTOP) to 1:45 (or 105 minutes) or 7 slots (105/15)
        slotSize (int): this is the size of the slots we wish to use. defaults to 15 minutes.
    	"""
	self.name = name
	self.start = start
	self.end = end
        self.maxTOP = maxTOP / slotSize
        self.slotSize = slotSize
	
    	#positionList (list) of (Position) objects in facility
    	#postions (dict) of posID's for keys assigned to (Position) values
    	self.positionList = []
    	self.positions = {}
    	
    	#employeeList (list) of (Employee) objects in facility
    	#employees (dict) of employee initials for keys assigned to (Employee) values
    	self.employeeList = []
    	self.employees = {}
    	
    	#create list of slots for facility
    	#create dictionary of lists of employees on break
    	#create dictionary of lists of employees on position
    	self.slotList = buildSlotList(self.start, self.end, slotSize)
        self.onBreak = buildSlots(self.slotList, "list")
        self.onPos = buildSlots(self.slotList, "list")
    
    def addPosition(self, pos):
        self.positionList.append(pos)
        self.positions[pos.getPosID()] = pos
        
    def addEmployee(self, person):
        self.employeeList.append(person)
        self.employees[person.getInitials()] = person
        
    def getNumSlots(self):
        return len(self.slotList)
        
    def getSlotList(self):
        return self.slotList
        
    def getSlotSize(self):
        return self.slotSize
        
    def getMaxTOP(self):
        return self.maxTOP
        
    def getPositionList(self):
        return self.positionList
        
    def removeFromBreakList(self, person, slot):
        self.onBreak[slot].remove(person)
        
    def buildBreakList(self):
        #we need to check if the breakList is empty first time through
        firstWalkThrough = True
        
        #iterate through every employee
        for employee in self.employeeList:
            ######################### TEST CODE
            print employee
            #if the employee is a closer
            if employee.getEOS() == self.end:
                #start him at the beginning and fill every slot until close
                for slot in self.getSlotList():
                    ######################### TEST CODE
                    print slot
                    
                    #check if it's our first time checking this slot and if it's empty
                    if firstWalkThrough and self.onBreak[slot]:
                        #if not empty, raise error
                        raise Exception("onBreak not empty before populating list in slot: " + str(slot))          
                    
                    #WE CONSOLIDATED THE FOLLOWING CODE TO ONE LINE FOR NOW. CANT SEE A REASON TO MAKE A COPY YET
                    #retrieve slot contents, add the employee to the break list, send it back
                    #breakList = self.onBreak[slot][:]
                    #breakList.append(employee)
                    #self.onBreak[slot] = breakList
                    
                    #add the employee to the break list
                    self.onBreak[slot].append(employee)                    
            #if the employee is not a closer
            elif employee.getEOS() < self.end:
                #iterate over every slot
                for slot in self.getSlotList():
                    ######################### TEST CODE
                    print slot
                    
                    #check if it's our first time checking this slot and if it's empty
                    if firstWalkThrough and self.onBreak[slot]:
                        #if not empty, raise error
                        raise Exception("onBreak not empty before populating list in slot: " + str(slot))
                    
                    #assign employee to break list while the slot is less than the employees end of shift
                    if slot < employee.getEOS():
                        #add the employee to the break list
                        self.onBreak[slot].append(employee)
                    #once we get to the employees End Of Shift, stop adding to break list
                    else:
                        break
            #otherwise the employees End Of Shift is outside the parameters
            else:
                raise Exception("Employee EOF outside parameters")
            #we made it though all slots without seeing an anomaly. set flag to false to stop checking
            firstWalkThrough = False
                        
                    
            
		
    ##### WORK IN PROGRESS #####
    def makeSomeoneWork(self):
	#randomly pick a lucky worker to assign a position
	lucky = random.choice(self.employeeList)
	
	#list of positions minus the last position employee worked
	options = self.positionList[:]
	if type(lucky.getLastPos()) == Position: #if last position is set...
	    options.remove(lucky.getLastPos()) #remove that position from the position list
	
	#randomly pick a position from the remaining positions
	pos = random.choice(options)
	
	#start assigning worker to position
        lucky.resetTOP()
	slotList = pos.getSlotList()[:]
	while lucky.getTOP < self.maxTOP:
            pos.assignWorker(slotList.pop(),lucky)
            lucky.increaseTOP()
        lucky.setLastPos(pos)
        print lucky ##### TEST CODE. REMOVE FOR PRODUCTION #####
        print pos ##### TEST CODE. REMOVE FOR PRODUCTION #####
        

##### TEST CODE #####
RSW = Facility("Fort Myers")

RSW.addEmployee(Employee("RB", 2400))
RSW.addEmployee(Employee("RC", 2400))
RSW.addEmployee(Employee("MT", 2300))
RSW.addEmployee(Employee("LB", 2130))
RSW.addEmployee(Employee("CA", 2030))
RSW.addEmployee(Employee("OL", 2030))

RSW.addPosition(Position("A", 15))
RSW.addPosition(Position("B", 15))

#scheduler builder function (facility object with employees and positions, standardTOP = 4 slots (60 minutes)):
def buildSchedule(facility, standardTOP = 60):
    #set standardTOP to number of actual slots and not minutes
    standardTOP /= facility.getSlotSize()
    
    def assignWorker():
        """
        internal function we'll call multiple times when we're adding an employee to a position
        """
        #...assign him to the slot
	pos.assignWorker(slot, employee, standardTOP)
	#...set their last position
	employee.setLastPos(pos)
        #..increase their TOP
        employee.increaseTOP(standardTOP)
        #...reset TOB counter
        employee.resetTOB()        	                
        #...remove from breakList
        facility.removeFromBreakList(employee, slot)          
    
    #loop through x number slots starting with closing slot
    slotList = facility.getSlotList()[:]
    slotList.reverse()
    for slot in slotList:
        #when standardTOP becomes less than slots available, reduce standardTOP by 1
	#loop through each position
        for pos in facility.getPositionList():
            #if slot for position is already set, skip
            if pos.checkSlot(slot):
                continue
            #check pool for available employees
            breakList = facility.onBreak.getSlot(slot)
            ######################TEST CODE
            print breakList
            #if none and it's the first slot
            if len(breakList) < 1 and slot == facility.getSlotList()[-1]:
                #throw exception
                raise Exception("Not enough employees available to close")
	    #if none
	    elif len(breakList) < 1:
	        #we need to extend the employee on position
	        #get the index of the current slot, add 1, then retrieve that slot from the slot list
	        employee = pos.whoIsWorking(pos.getSlotList()[pos.getSlotList().index(slot) + 1])
	        #if employee is already at maxTOP throw exception
                if employee.getTOP() >= facility.getMaxTOP():
                    raise Exception(employee.getInitials() + " has reached max Time On Position (maxTOP)")
                #else extend assigned employee one slot
                else:
                    #...assign him to the slot
                    pos.assignWorker(slot, employee) #one slot is implied
                    #..increase their TOP
                    employee.increaseTOP()	                
	            #...remove from breakList
        	    facility.removeFromBreakList(employee, slot)                     
            #elif one
            #########################################
            ######################################### WORK ON THIS!
            elif len(breakList) == 1:
                #fetch the employee
                employee = breakList[0]
                #call assignWorker function
                assignWorker()
            ##########################################
            ##########################################
	    #elif more than one...
	    elif len(breakList) > 1:
	        #iterate over everyone on break
	        #and keep track of who's been on break the longest
	        longestTOB = 0
	        lucky = None
	        for employee in breakList:
                    #check to see if anyone hasn't worked
	            #if we find one who hasn't worked...
	            if employee.getLastPos() == None:
                        #call assignWorker function
                        assignWorker()	               
	                #...and move on to the next positioin
	                break
	            #since we got this far, this person has worked before. See if they've been on break the longest
	            if employee.getTOB() > longestTOB:
	                #if yes, make them the new lucky victim
	                lucky = employee
                #else everyone's worked, check who's been on break the longest. A tie will just go to the first person we checked
                #switch back to employee so we can use assignWorker function
                employee = lucky
                #assign that person to the position
                assignWorker()
        #after going through all positions, check who's left on break and add one to their TOB counter
        breakList = facility.onBreak.getSlot(slot)
        for employee in breakList:
            employee.setTOBplus1()

		
#build schedule table to print
import pandas

"""
Here's the format we're looking for

	POS	POS
SLOT	RB	MT
SLOT	RB	MT
SLOT	RB	MT
SLOT	RB	MT

So first column will be the slots
the rest of the columns will be employee's initials assigned to the postion found at the top of the column

each column needs to be formatted into a dictionary
the heading is the key and the rest are values
the slot times need to be in a list
"""

def displaySchedule(facility):
    #initialize dictionary of position assignments
    posAssignments = {}
    #iterate over every position in the facility
    for pos in facility.getPositionList():
       	#create empty list for this position to fill
       	posAssignments[pos.getPosID()] = []
	#iterate over every slot
	for slot in facility.getSlotList():
	   #fetch employee working this slot
	   employee = pos.whoIsWorking(slot)
	   #if employee is indeed an employee...
	   if type(employee) == Employee:
	       #get the initials of the person working for each slot for each position
	       posAssignments[pos.getPosID()].append(employee.getInitials())
	   #...otherwise add "" to the posAssignment for whitespace
	   else:
	       posAssignments[pos.getPosID()].append("")
    #use the pandas DataFrame method to create readable tabulated lists for print
    print pandas.DataFrame(posAssignments, index=facility.getSlotList())
    
#test code for Scheduler

#1. Call basicSchedule
#from basicSchedule0.22 import *
#
#2. Build Break List
RSW.buildBreakList()
#
#3. Build Schedule
#buildSchedule(RSW)
#
#4. Display Schedule
#displaySchedule(RSW)
